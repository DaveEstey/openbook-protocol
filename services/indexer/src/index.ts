import pino from 'pino';
import { config } from './config';
import { Database } from './db/client';
import { EventProcessor } from './processors/event-processor';
import { SolanaListener } from './listeners/solana-listener';
import { IndexedEvent } from './types/events';

// Note: In production, load these from ../../target/idl/*.json after building programs
// For now, these are placeholders - IDLs will be generated by Anchor build
const IDL_CAMPAIGN = {} as any; // Load from target/idl/campaign_registry.json
const IDL_TASK = {} as any; // Load from target/idl/task_manager.json
const IDL_BUDGET = {} as any; // Load from target/idl/budget_vote.json
const IDL_ESCROW = {} as any; // Load from target/idl/task_escrow.json
const IDL_PROOF = {} as any; // Load from target/idl/proof_registry.json
const IDL_DISPUTE = {} as any; // Load from target/idl/dispute_module.json
const IDL_GOVERNANCE = {} as any; // Load from target/idl/governance_token.json

const logger = pino({
  name: 'indexer',
  level: config.logLevel,
  transport:
    process.env.NODE_ENV === 'development'
      ? { target: 'pino-pretty', options: { colorize: true } }
      : undefined,
});

class Indexer {
  private db: Database;
  private eventProcessor: EventProcessor;
  private listener: SolanaListener;
  private isShuttingDown: boolean = false;

  constructor() {
    this.db = new Database(config.databaseUrl);
    this.eventProcessor = new EventProcessor();

    // Configure program listeners
    const programConfigs = new Map([
      ['campaign', { programId: config.programIds.campaign, idl: IDL_CAMPAIGN }],
      ['task', { programId: config.programIds.task, idl: IDL_TASK }],
      ['budget', { programId: config.programIds.budget, idl: IDL_BUDGET }],
      ['escrow', { programId: config.programIds.escrow, idl: IDL_ESCROW }],
      ['proof', { programId: config.programIds.proof, idl: IDL_PROOF }],
      ['dispute', { programId: config.programIds.dispute, idl: IDL_DISPUTE }],
      ['governance', { programId: config.programIds.governance, idl: IDL_GOVERNANCE }],
    ]);

    this.listener = new SolanaListener(
      config.solanaRpcUrl,
      config.solanaRpcFallbackUrl,
      programConfigs,
      config.startSlot
    );

    logger.info({ config }, 'Indexer initialized');
  }

  async start(): Promise<void> {
    logger.info('Starting OpenBook Indexer');

    // Restore last processed slot from database
    const lastSlot = await this.getLastProcessedSlot();
    if (lastSlot > 0) {
      this.listener.setLastProcessedSlot(lastSlot);
      logger.info({ lastSlot }, 'Resuming from last processed slot');
    }

    // Set up graceful shutdown
    process.on('SIGINT', () => this.shutdown());
    process.on('SIGTERM', () => this.shutdown());

    // Start listening
    await this.listener.start((event) => this.handleEvent(event));
  }

  private async handleEvent(event: IndexedEvent): Promise<void> {
    if (this.isShuttingDown) {
      return;
    }

    try {
      // Process event within a database transaction (idempotent)
      await this.db.transaction(async (client) => {
        const processed = await this.eventProcessor.processEvent(client, event);

        if (processed) {
          // Update last processed slot
          await client.query(
            'UPDATE indexer_state SET last_processed_slot = $1, last_processed_signature = $2, updated_at = NOW() WHERE id = 1',
            [event.slot, event.signature]
          );
        }
      });

      logger.debug({ signature: event.signature, type: event.eventType }, 'Event handled');
    } catch (error) {
      logger.error({ event, error }, 'Failed to handle event');
      throw error; // Will trigger retry logic in listener
    }
  }

  private async getLastProcessedSlot(): Promise<number> {
    const result = await this.db.query('SELECT last_processed_slot FROM indexer_state WHERE id = 1');
    return result.rows[0]?.last_processed_slot || 0;
  }

  private async shutdown(): Promise<void> {
    if (this.isShuttingDown) {
      return;
    }

    this.isShuttingDown = true;
    logger.info('Shutting down gracefully...');

    this.listener.stop();
    await this.db.close();

    logger.info('Shutdown complete');
    process.exit(0);
  }
}

// Start the indexer
const indexer = new Indexer();
indexer.start().catch((error) => {
  logger.fatal({ error }, 'Indexer failed to start');
  process.exit(1);
});
